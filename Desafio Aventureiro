#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

void limparEntrada() {
    int c;
    while ((c = getchar()) != '\n' && c != EOF) { }
}

typedef struct {
    char nome[30];
    char cor[10];
    int tropas;
} Territorio;

Territorio* cadastrarTerritoriosDinamico(int *n) {
    printf("Informe o número de territórios: ");
    if (scanf("%d", n) != 1 || *n <= 0) {
        printf("Valor inválido. Usando 5 por padrão.\n");
        *n = 5;
    }
    limparEntrada();
    Territorio *mapa = (Territorio*) calloc(*n, sizeof(Territorio));
    if (!mapa) {
        printf("Falha ao alocar memória.\n");
        exit(EXIT_FAILURE);
    }

    for (int i = 0; i < *n; i++) {
        printf("\n--- Território %d ---\n", i + 1);
        printf("Nome: ");
        fgets(mapa[i].nome, sizeof(mapa[i].nome), stdin);
        mapa[i].nome[strcspn(mapa[i].nome, "\n")] = '\0';

        printf("Cor do exército: ");
        fgets(mapa[i].cor, sizeof(mapa[i].cor), stdin);
        mapa[i].cor[strcspn(mapa[i].cor, "\n")] = '\0';

        printf("Tropas: ");
        scanf("%d", &mapa[i].tropas);
        limparEntrada();
        if (mapa[i].tropas < 0) mapa[i].tropas = 0;
    }

    return mapa;
}

void exibirMapa(const Territorio *mapa, int n) {
    printf("\n=== MAPA ATUAL ===\n");
    for (int i = 0; i < n; i++) {
        printf("%d) %s | Cor: %s | Tropas: %d\n",
               i, mapa[i].nome, mapa[i].cor, mapa[i].tropas);
    }
}

void atacar(Territorio* atacante, Territorio* defensor) {
    if (!atacante || !defensor) return;

    int dadoAtac = (rand() % 6) + 1;
    int dadoDef  = (rand() % 6) + 1;
    printf("\nRolagens: Atacante=%d | Defensor=%d\n", dadoAtac, dadoDef);

    if (dadoAtac > dadoDef) {
        printf("Resultado: Vitória do atacante!\n");
 
        strncpy(defensor->cor, atacante->cor, sizeof(defensor->cor) - 1);
        defensor->cor[sizeof(defensor->cor) - 1] = '\0';
        defensor->tropas = (atacante->tropas / 2);
        if (defensor->tropas < 1) defensor->tropas = 1; 
    } else if (dadoAtac < dadoDef) {
        printf("Resultado: Defesa bem-sucedida.\n");
        if (atacante->tropas > 0) atacante->tropas -= 1;
    } else {
        printf("Empate: sem mudanças significativas.\n");
    }
}

void moduloWarAtaque() {
    int n;
    Territorio *mapa = cadastrarTerritoriosDinamico(&n);

    int opc;
    do {
        exibirMapa(mapa, n);
        printf("\n1 - Atacar\n0 - Sair\nEscolha: ");
        if (scanf("%d", &opc) != 1) { limparEntrada(); opc = -1; continue; }
        limparEntrada();

        if (opc == 1) {
            int ia, id;
            printf("Índice do território atacante: ");
            if (scanf("%d", &ia) != 1) { limparEntrada(); continue; }
            printf("Índice do território defensor: ");
            if (scanf("%d", &id) != 1) { limparEntrada(); continue; }
            limparEntrada();

            if (ia < 0 || ia >= n || id < 0 || id >= n || ia == id) {
                printf("Índices inválidos.\n");
                continue;
            }
            if (strcmp(mapa[ia].cor, mapa[id].cor) == 0) {
                printf("Não é permitido atacar território da mesma cor!\n");
                continue;
            }
            atacar(&mapa[ia], &mapa[id]);
            exibirMapa(mapa, n);
        } else if (opc != 0) {
            printf("Opção inválida.\n");
        }
    } while (opc != 0);

    free(mapa);
}

typedef struct {
    char nome[30];
    char tipo[20];
    int quantidade;
} Item;

#define MAX_ITENS 50
typedef struct {
    Item v[MAX_ITENS];
    int tamanho;
    int ordenado; 
} MochilaVetor;

void initVetor(MochilaVetor *m) { m->tamanho = 0; m->ordenado = 0; }

void inserirItemVetor(MochilaVetor *m) {
    if (m->tamanho >= MAX_ITENS) { printf("Mochila (vetor) cheia.\n"); return; }
    Item it;
    printf("Nome: "); fgets(it.nome, sizeof(it.nome), stdin); it.nome[strcspn(it.nome, "\n")] = '\0';
    printf("Tipo: "); fgets(it.tipo, sizeof(it.tipo), stdin); it.tipo[strcspn(it.tipo, "\n")] = '\0';
    printf("Quantidade: "); if (scanf("%d", &it.quantidade) != 1) { limparEntrada(); return; } limparEntrada();
    if (it.quantidade < 0) it.quantidade = 0;
    m->v[m->tamanho++] = it;
    m->ordenado = 0;
    printf("Inserido no vetor.\n");
}

void removerItemVetor(MochilaVetor *m) {
    if (m->tamanho == 0) { printf("Mochila vazia.\n"); return; }
    char alvo[30];
    printf("Remover por nome: "); fgets(alvo, sizeof(alvo), stdin); alvo[strcspn(alvo, "\n")] = '\0';
    for (int i = 0; i < m->tamanho; i++) {
        if (strcmp(m->v[i].nome, alvo) == 0) {
            for (int j = i; j < m->tamanho - 1; j++) m->v[j] = m->v[j+1];
            m->tamanho--; printf("Removido do vetor.\n"); return;
        }
    }
    printf("Item não encontrado.\n");
}

void listarItensVetor(const MochilaVetor *m) {
    printf("\n--- Itens (vetor) ---\n");
    if (m->tamanho == 0) { printf("(sem itens)\n"); return; }
    for (int i = 0; i < m->tamanho; i++) {
        printf("%s | Tipo: %s | Qtd: %d\n", m->v[i].nome, m->v[i].tipo, m->v[i].quantidade);
    }
}

int buscarSequencialVetor(const MochilaVetor *m, const char *nome, int *comparacoes) {
    *comparacoes = 0;
    for (int i = 0; i < m->tamanho; i++) {
        (*comparacoes)++;
        if (strcmp(m->v[i].nome, nome) == 0) return i;
    }
    return -1;
}

void ordenarVetor(MochilaVetor *m) {
 
    for (int i = 0; i < m->tamanho - 1; i++) {
        for (int j = 0; j < m->tamanho - 1 - i; j++) {
            if (strcmp(m->v[j].nome, m->v[j+1].nome) > 0) {
                Item tmp = m->v[j]; m->v[j] = m->v[j+1]; m->v[j+1] = tmp;
            }
        }
    }
    m->ordenado = 1;
    printf("Vetor ordenado por nome.\n");
}

int buscarBinariaVetor(const MochilaVetor *m, const char *nome, int *comparacoes) {
    *comparacoes = 0;
    if (!m->ordenado) {
        printf("Atenção: é necessário ordenar antes da busca binária.\n");
        return -1;
    }
    int l = 0, r = m->tamanho - 1;
    while (l <= r) {
        int mid = (l + r) / 2;
        (*comparacoes)++;
        int cmp = strcmp(m->v[mid].nome, nome);
        if (cmp == 0) return mid;
        if (cmp < 0) l = mid + 1; else r = mid - 1;
    }
    return -1;
}

typedef struct No {
    Item dados;
    struct No* proximo;
} No;

typedef struct {
    No* inicio;
} MochilaLista;

void initLista(MochilaLista *ml) { ml->inicio = NULL; }

void inserirItemLista(MochilaLista *ml) {
    No* novo = (No*) malloc(sizeof(No));
    if (!novo) { printf("Falha de memória.\n"); return; }
    printf("Nome: "); fgets(novo->dados.nome, sizeof(novo->dados.nome), stdin);
    novo->dados.nome[strcspn(novo->dados.nome, "\n")] = '\0';
    printf("Tipo: "); fgets(novo->dados.tipo, sizeof(novo->dados.tipo), stdin);
    novo->dados.tipo[strcspn(novo->dados.tipo, "\n")] = '\0';
    printf("Quantidade: "); if (scanf("%d", &novo->dados.quantidade) != 1) { limparEntrada(); free(novo); return; }
    limparEntrada();
    if (novo->dados.quantidade < 0) novo->dados.quantidade = 0;
    novo->proximo = NULL;

    if (!ml->inicio) ml->inicio = novo;
    else {
        No* aux = ml->inicio;
        while (aux->proximo) aux = aux->proximo;
        aux->proximo = novo;
    }
    printf("Inserido na lista.\n");
}

void removerItemLista(MochilaLista *ml) {
    if (!ml->inicio) { printf("Lista vazia.\n"); return; }
    char alvo[30];
    printf("Remover por nome: "); fgets(alvo, sizeof(alvo), stdin); alvo[strcspn(alvo, "\n")] = '\0';

    No *ant = NULL, *cur = ml->inicio;
    while (cur) {
        if (strcmp(cur->dados.nome, alvo) == 0) {
            if (ant) ant->proximo = cur->proximo; else ml->inicio = cur->proximo;
            free(cur);
            printf("Removido da lista.\n");
            return;
        }
        ant = cur; cur = cur->proximo;
    }
    printf("Item não encontrado.\n");
}

void listarItensLista(const MochilaLista *ml) {
    printf("\n--- Itens (lista) ---\n");
    if (!ml->inicio) { printf("(sem itens)\n"); return; }
    for (No* p = ml->inicio; p; p = p->proximo) {
        printf("%s | Tipo: %s | Qtd: %d\n", p->dados.nome, p->dados.tipo, p->dados.quantidade);
    }
}

int buscarSequencialLista(const MochilaLista *ml, const char *nome, int *comparacoes) {
    *comparacoes = 0;
    for (No* p = ml->inicio; p; p = p->proximo) {
        (*comparacoes)++;
        if (strcmp(p->dados.nome, nome) == 0) return 1; 
    }
    return 0; 
}

void liberarLista(MochilaLista *ml) {
    No* p = ml->inicio;
    while (p) { No* nxt = p->proximo; free(p); p = nxt; }
    ml->inicio = NULL;
}

void moduloInventarioComparado() {
    MochilaVetor mv; initVetor(&mv);
    MochilaLista ml; initLista(&ml);

    int opcEstrutura;
    do {
        printf("\n=== Inventário: escolha estrutura ===\n");
        printf("1 - Vetor\n2 - Lista encadeada\n0 - Sair\nEscolha: ");
        if (scanf("%d", &opcEstrutura) != 1) { limparEntrada(); opcEstrutura = -1; continue; }
        limparEntrada();

        if (opcEstrutura == 1) {
            int op;
            do {
                printf("\n[Vetor] 1-Inserir 2-Remover 3-Listar 4-Buscar Seq 5-Ordenar 6-Buscar Bin 0-Voltar\nEscolha: ");
                if (scanf("%d", &op) != 1) { limparEntrada(); op = -1; continue; }
                limparEntrada();
                if (op == 1) inserirItemVetor(&mv);
                else if (op == 2) removerItemVetor(&mv);
                else if (op == 3) listarItensVetor(&mv);
                else if (op == 4) {
                    char alvo[30]; int comps;
                    printf("Nome a buscar (seq): "); fgets(alvo, sizeof(alvo), stdin); alvo[strcspn(alvo, "\n")] = '\0';
                    int idx = buscarSequencialVetor(&mv, alvo, &comps);
                    if (idx >= 0) printf("Encontrado no índice %d | comparações: %d\n", idx, comps);
                    else printf("Não encontrado | comparações: %d\n", comps);
                }
                else if (op == 5) ordenarVetor(&mv);
                else if (op == 6) {
                    char alvo[30]; int comps;
                    printf("Nome a buscar (binária): "); fgets(alvo, sizeof(alvo), stdin); alvo[strcspn(alvo, "\n")] = '\0';
                    int idx = buscarBinariaVetor(&mv, alvo, &comps);
                    if (idx >= 0) printf("Encontrado no índice %d | comparações: %d\n", idx, comps);
                    else printf("Não encontrado | comparações: %d\n", comps);
                }
            } while (op != 0);
        } else if (opcEstrutura == 2) {
            int op;
            do {
                printf("\n[Lista] 1-Inserir 2-Remover 3-Listar 4-Buscar Seq 0-Voltar\nEscolha: ");
                if (scanf("%d", &op) != 1) { limparEntrada(); op = -1; continue; }
                limparEntrada();
                if (op == 1) inserirItemLista(&ml);
                else if (op == 2) removerItemLista(&ml);
                else if (op == 3) listarItensLista(&ml);
                else if (op == 4) {
                    char alvo[30]; int comps;
                    printf("Nome a buscar (seq): "); fgets(alvo, sizeof(alvo), stdin); alvo[strcspn(alvo, "\n")] = '\0';
                    int ok = buscarSequencialLista(&ml, alvo, &comps);
                    if (ok) printf("Encontrado | comparações: %d\n", comps);
                    else printf("Não encontrado | comparações: %d\n", comps);
                }
            } while (op != 0);
        } else if (opcEstrutura != 0) {
            printf("Opção inválida.\n");
        }
    } while (opcEstrutura != 0);

    liberarLista(&ml);
}


typedef struct {
    char nome; 
    int id;    
} Peca;

#define TAM_FILA 5
#define TAM_PILHA 3

typedef struct {
    Peca dados[TAM_FILA];
    int frente, tras, qtd;
} Fila;

typedef struct {
    Peca dados[TAM_PILHA];
    int topo; // -1 vazia
} Pilha;

char tiposPeca[] = {'I','O','T','L'};
int idGlobal = 0;

Peca gerarPeca() {
    Peca p;
    p.nome = tiposPeca[rand() % 4];
    p.id = idGlobal++;
    return p;
}

void initFila(Fila *f) { f->frente = 0; f->tras = -1; f->qtd = 0; }
int filaCheia(Fila *f) { return f->qtd == TAM_FILA; }
int filaVazia(Fila *f) { return f->qtd == 0; }

void enqueue(Fila *f, Peca p) {
    if (filaCheia(f)) return;
    f->tras = (f->tras + 1) % TAM_FILA;
    f->dados[f->tras] = p;
    f->qtd++;
}

Peca dequeue(Fila *f, int *ok) {
    Peca ret = {'?', -1};
    *ok = 0;
    if (filaVazia(f)) return ret;
    ret = f->dados[f->frente];
    f->frente = (f->frente + 1) % TAM_FILA;
    f->qtd--;
    *ok = 1;
    return ret;
}

void initPilha(Pilha *p) { p->topo = -1; }
int pilhaCheia(Pilha *p) { return p->topo == TAM_PILHA - 1; }
int pilhaVazia(Pilha *p) { return p->topo == -1; }

int push(Pilha *p, Peca x) {
    if (pilhaCheia(p)) return 0;
    p->dados[++p->topo] = x;
    return 1;
}

Peca pop(Pilha *p, int *ok) {
    Peca ret = {'?', -1}; *ok = 0;
    if (pilhaVazia(p)) return ret;
    ret = p->dados[p->topo--];
    *ok = 1;
    return ret;
}

void mostrarEstado(const Fila *f, const Pilha *p) {
    printf("\nEstado atual:\n");
    printf("Fila de peças: ");
    if (f->qtd == 0) printf("(vazia)");
    else {
        for (int i = 0; i < f->qtd; i++) {
            int idx = (f->frente + i) % TAM_FILA;
            printf("[%c %d] ", f->dados[idx].nome, f->dados[idx].id);
        }
    }
    printf("\nPilha de reserva (Topo -> Base): ");
    if (p->topo < 0) printf("(vazia)");
    else {
        for (int i = p->topo; i >= 0; i--) {
            printf("[%c %d] ", p->dados[i].nome, p->dados[i].id);
        }
    }
    printf("\n");
}

void moduloTetrisFilaPilha() {
    Fila f; Pilha p;
    initFila(&f); initPilha(&p);

    for (int i = 0; i < TAM_FILA; i++) enqueue(&f, gerarPeca());

    int opc;
    do {
        mostrarEstado(&f, &p);
        printf("\n1 - Jogar peça\n2 - Reservar peça\n3 - Usar peça reservada\n0 - Sair\nEscolha: ");
        if (scanf("%d", &opc) != 1) { limparEntrada(); opc = -1; continue; }
        limparEntrada();

        if (opc == 1) {
            int ok; Peca jogada = dequeue(&f, &ok);
            if (!ok) { printf("Fila vazia.\n"); }
            else {
                printf("Jogou: [%c %d]\n", jogada.nome, jogada.id);
        
                enqueue(&f, gerarPeca());
            }
        } else if (opc == 2) {
            if (pilhaCheia(&p)) { printf("Reserva cheia.\n"); }
            else {
                int ok; Peca mov = dequeue(&f, &ok);
                if (!ok) { printf("Fila vazia.\n"); }
                else {
                    push(&p, mov);
                    printf("Reservou: [%c %d]\n", mov.nome, mov.id);
                    enqueue(&f, gerarPeca()); // mantém a fila cheia
                }
            }
        } else if (opc == 3) {
            int ok; Peca usado = pop(&p, &ok);
            if (!ok) printf("Reserva vazia.\n");
            else printf("Usou reservado: [%c %d]\n", usado.nome, usado.id);

        } else if (opc == 0) {
            printf("Voltando ao menu principal...\n");
        } else {
            printf("Opção inválida.\n");
        }
    } while (opc != 0);
}

typedef struct Sala {
    char nome[50];
    char pista[80]; 
    struct Sala *esq;
    struct Sala *dir;
} Sala;

typedef struct PistaNode {
    char pista[80];
    struct PistaNode *esq, *dir;
} PistaNode;

Sala* criarSala(const char *nome, const char *pista) {
    Sala *s = (Sala*) malloc(sizeof(Sala));
    if (!s) { printf("Falha de memória.\n"); exit(EXIT_FAILURE); }
    strncpy(s->nome, nome, sizeof(s->nome)-1); s->nome[sizeof(s->nome)-1] = '\0';
    if (pista) { strncpy(s->pista, pista, sizeof(s->pista)-1); s->pista[sizeof(s->pista)-1] = '\0'; }
    else s->pista[0] = '\0';
    s->esq = s->dir = NULL;
    return s;
}

void liberarMapa(Sala *r) {
    if (!r) return;
    liberarMapa(r->esq);
    liberarMapa(r->dir);
    free(r);
}

PistaNode* inserirPista(PistaNode *raiz, const char *pista) {
    if (!pista || pista[0] == '\0') return raiz;
    if (!raiz) {
        PistaNode *n = (PistaNode*) malloc(sizeof(PistaNode));
        if (!n) { printf("Falha de memória.\n"); exit(EXIT_FAILURE); }
        strncpy(n->pista, pista, sizeof(n->pista)-1);
        n->pista[sizeof(n->pista)-1] = '\0';
        n->esq = n->dir = NULL;
        return n;
    }
    int cmp = strcmp(pista, raiz->pista);
    if (cmp < 0) raiz->esq = inserirPista(raiz->esq, pista);
    else if (cmp > 0) raiz->dir = inserirPista(raiz->dir, pista);
   
    return raiz;
}

void exibirPistas(PistaNode *r) {
    if (!r) return;
    exibirPistas(r->esq);
    printf("- %s\n", r->pista);
    exibirPistas(r->dir);
}

void liberarBST(PistaNode *r) {
    if (!r) return;
    liberarBST(r->esq);
    liberarBST(r->dir);
    free(r);
}

void explorarSalasComPistas(Sala *inicio, PistaNode **colecao) {
    Sala *atual = inicio;
    char escolha;
    while (atual) {
        printf("\nVocê está em: %s\n", atual->nome);
        if (atual->pista[0] != '\0') {
            printf("Pista encontrada: \"%s\" (adicionada à coleção)\n", atual->pista);
            *colecao = inserirPista(*colecao, atual->pista);
        } else {
            printf("Nenhuma pista aqui.\n");
        }

        printf("Escolha (e) esquerda, (d) direita, (s) sair: ");
        if (scanf(" %c", &escolha) != 1) { limparEntrada(); continue; }
        limparEntrada();
        if (escolha == 'e' || escolha == 'E') atual = atual->esq;
        else if (escolha == 'd' || escolha == 'D') atual = atual->dir;
        else if (escolha == 's' || escolha == 'S') break;
        else printf("Opção inválida.\n");
    }
}

void moduloDetectivePistas() {
    Sala *hall = criarSala("Hall de Entrada", "Pegadas de lama");
    hall->esq = criarSala("Sala de Estar", "");
    hall->dir = criarSala("Cozinha", "Faca ausente");
    hall->esq->esq = criarSala("Biblioteca", "Livro fora de lugar");
    hall->esq->dir = criarSala("Jardim", "Flor recém-pisoteada");
    hall->dir->esq = criarSala("Despensa", "");
    hall->dir->dir = criarSala("Garagem", "Rastro de pneu molhado");

    PistaNode *colecao = NULL;

    explorarSalasComPistas(hall, &colecao);

    printf("\n=== Pistas coletadas (ordem alfabética) ===\n");
    if (!colecao) printf("(nenhuma pista)\n");
    else exibirPistas(colecao);

    liberarMapa(hall);
    liberarBST(colecao);
}

int main() {
    srand((unsigned)time(NULL));

    int opc;
    do {
        printf("\n=== DESAFIOS — Nível Aventureiro ===\n");
        printf("1 - War: Ataque entre territórios (dinâmico)\n");
        printf("2 - Inventário: Vetor x Lista (ordenação + buscas)\n");
        printf("3 - Tetris: Fila + Pilha de reserva\n");
        printf("4 - Detective Quest: Pistas com BST\n");
        printf("0 - Sair\nEscolha: ");
        if (scanf("%d", &opc) != 1) { limparEntrada(); opc = -1; continue; }
        limparEntrada();

        switch (opc) {
            case 1: moduloWarAtaque(); break;
            case 2: moduloInventarioComparado(); break;
            case 3: moduloTetrisFilaPilha(); break;
            case 4: moduloDetectivePistas(); break;
            case 0: printf("Saindo...\n"); break;
            default: printf("Opção inválida.\n"); break;
        }
    } while (opc != 0);

    return 0;
}
